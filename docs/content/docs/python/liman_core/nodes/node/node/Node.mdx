---
title: Node
---

Generic custom node for implementing specialized logic.

Provides a base implementation for custom nodes that don't fit
into LLM or Tool categories. Currently a placeholder implementation.

## Attributes

<PyAttribute name={"spec_type"} type={null} value={"NodeSpec"} />

<PyAttribute name={"registry"} type={null} value={"registry"} />

## Functions

<PyFunction name={"__init__"} type={"__init__(self, /, spec, registry, *, initial_data=None, yaml_path=None, strict=False, default_lang='en', fallback_lang='en') -> None"}>

Initialize custom node with specification and registry.

Args:
spec: Node specification defining custom node configuration
registry: Component registry for dependency resolution
initial_data: Optional initial data for the component
yaml_path: Optional path to the YAML file this node was loaded from
strict: Whether to enforce strict validation
default_lang: Default language code for localization
fallback_lang: Fallback language code when default is unavailable

<PySourceCode >

```python
def __init__(
    self,
    spec: NodeSpec,
    registry: Registry,
    *,
    initial_data: dict[str, Any] | None = None,
    yaml_path: str | None = None,
    strict: bool = False,
    default_lang: str = "en",
    fallback_lang: str = "en",
) -> None:
    """
    Initialize custom node with specification and registry.

    Args:
        spec: Node specification defining custom node configuration
        registry: Component registry for dependency resolution
        initial_data: Optional initial data for the component
        yaml_path: Optional path to the YAML file this node was loaded from
        strict: Whether to enforce strict validation
        default_lang: Default language code for localization
        fallback_lang: Fallback language code when default is unavailable
    """
    super().__init__(
        spec,
        registry,
        initial_data=initial_data,
        yaml_path=yaml_path,
        default_lang=default_lang,
        fallback_lang=fallback_lang,
        strict=strict,
    )

    self.registry = registry
    self.registry.add(self)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"spec"} type={"NodeSpec"} value={null} />
<PyParameter name={"registry"} type={"Registry"} value={null} />
<PyParameter
  name={"initial_data"}
  type={"dict[str, Any] | None"}
  value={"None"}
/>
<PyParameter name={"yaml_path"} type={"str | None"} value={"None"} />
<PyParameter name={"strict"} type={"bool"} value={"False"} />
<PyParameter name={"default_lang"} type={"str"} value={"'en'"} />
<PyParameter name={"fallback_lang"} type={"str"} value={"'en'"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"compile"} type={"compile(self) -> None"}>

Compile the custom node for execution.

Performs basic validation and preparation for execution.

Raises:
LimanError: If the node is already compiled

<PySourceCode >

```python
def compile(self) -> None:
    """
    Compile the custom node for execution.

    Performs basic validation and preparation for execution.

    Raises:
        LimanError: If the node is already compiled
    """
    if self._compiled:
        raise LimanError("Node is already compiled")

    self._compiled = True
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"invoke"} type={"invoke(self, /, inputs, state, **kwargs) -> Any"}>

Execute the custom node logic.

Currently not implemented - placeholder for future custom node logic.

Args:
inputs: Sequence of input messages
state: Current execution state
\*\*kwargs: Additional keyword arguments

Returns:
Result of node execution

Raises:
NotImplementedError: Method is not yet implemented

<PySourceCode >

```python
async def invoke(
    self, inputs: Sequence[BaseMessage], state: dict[str, Any], **kwargs: Any
) -> Any:
    """
    Execute the custom node logic.

    Currently not implemented - placeholder for future custom node logic.

    Args:
        inputs: Sequence of input messages
        state: Current execution state
        **kwargs: Additional keyword arguments

    Returns:
        Result of node execution

    Raises:
        NotImplementedError: Method is not yet implemented
    """
    raise NotImplementedError("Node.ainvoke() is not implemented yet")
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"inputs"} type={"Sequence[BaseMessage]"} value={null} />
<PyParameter name={"state"} type={"dict[str, Any]"} value={null} />
<PyParameter name={"kwargs"} type={"Any"} value={"{}"} />

</div>

<PyFunctionReturn type={"Any"} />

</PyFunction>

<PyFunction name={"get_new_state"} type={"get_new_state(self) -> NodeState"}>

Create new state instance for this custom node.

Returns:
Fresh NodeState with empty message history

<PySourceCode >

```python
def get_new_state(self) -> NodeState:
    """
    Create new state instance for this custom node.

    Returns:
        Fresh NodeState with empty message history
    """
    return NodeState(name=self.spec.name, messages=[])
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"NodeState"} />

</PyFunction>
