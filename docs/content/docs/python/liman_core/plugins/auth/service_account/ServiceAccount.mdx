---
title: ServiceAccount
---

ServiceAccount provides authentication and authorization context for node execution

## Functions

<PyFunction name={"from_dict"} type={"from_dict(cls, /, data, registry, *, yaml_path=None, strict=False, **kwargs) -> Self"}>

<PySourceCode >

```python
@classmethod
def from_dict(
    cls,
    data: dict[str, Any],
    registry: Registry,
    *,
    yaml_path: str | None = None,
    strict: bool = False,
    **kwargs: Any,
) -> Self:
    spec = ServiceAccountSpec(**data)
    return cls(
        spec,
        registry,
        initial_data=data,
        yaml_path=yaml_path,
        strict=strict,
    )
```

</PySourceCode>

<div >

<PyParameter name={"cls"} type={null} value={null} />
<PyParameter name={"data"} type={"dict[str, Any]"} value={null} />
<PyParameter name={"registry"} type={"Registry"} value={null} />
<PyParameter name={"yaml_path"} type={"str | None"} value={"None"} />
<PyParameter name={"strict"} type={"bool"} value={"False"} />
<PyParameter name={"kwargs"} type={"Any"} value={"{}"} />

</div>

<PyFunctionReturn type={"Self"} />

</PyFunction>

<PyFunction name={"from_yaml_path"} type={"from_yaml_path(cls, /, yaml_path, registry, *, strict=True, **kwargs) -> Self"}>

Create a ServiceAccount from a YAML file.

Args:
yaml_path (str): Path to the YAML file.

Returns:
ServiceAccount: An instance of ServiceAccount initialized with the YAML data.

<PySourceCode >

```python
@classmethod
def from_yaml_path(
    cls,
    yaml_path: str | Path,
    registry: Registry,
    *,
    strict: bool = True,
    **kwargs: Any,
) -> Self:
    """
    Create a ServiceAccount from a YAML file.

    Args:
        yaml_path (str): Path to the YAML file.

    Returns:
        ServiceAccount: An instance of ServiceAccount initialized with the YAML data.
    """
    yaml = YAML()
    yaml_path_str = str(yaml_path)
    with open(yaml_path_str, encoding="utf-8") as fd:
        yaml_data = yaml.load(fd)

    if not isinstance(yaml_data, dict):
        raise InvalidSpecError(
            "YAML content must be a dictionary at the top level."
        )

    return cls.from_dict(
        yaml_data,
        registry,
        yaml_path=yaml_path_str,
        strict=strict,
        **kwargs,
    )
```

</PySourceCode>

<div >

<PyParameter name={"cls"} type={null} value={null} />
<PyParameter name={"yaml_path"} type={"str | Path"} value={null} />
<PyParameter name={"registry"} type={"Registry"} value={null} />
<PyParameter name={"strict"} type={"bool"} value={"True"} />
<PyParameter name={"kwargs"} type={"Any"} value={"{}"} />

</div>

<PyFunctionReturn type={"Self"} />

</PyFunction>

<PyFunction name={"get_internal_state"} type={"get_internal_state(self, /, external_state) -> dict[str, Any]"}>

Extract and return internal state from external state based on inject configuration

<PySourceCode >

```python
def get_internal_state(self, external_state: dict[str, Any]) -> dict[str, Any]:
    """
    Extract and return internal state from external state based on inject configuration
    """
    if not self.spec.context:
        return {}

    context_vars: dict[str, Any] = {}

    for var_spec in self.spec.context.inject:
        if ":" in var_spec:
            # Custom name assignment (e.g., "user_id: user.id")
            # would be accessed as self.context.user_id
            target_name, source_path = var_spec.split(":", 1)
            target_name = target_name.strip()
            source_path = source_path.strip()
        else:
            # Direct variable name (e.g., "organization.id")
            # would be accesed as self.context.organization.id
            target_name = var_spec
            source_path = var_spec

        # Navigate nested dictionary using dot notation
        value = self._get_nested_value(external_state, source_path)

        if value is None and self.spec.context.strict:
            raise ValueError(
                f"Required context variable not found in state: '{source_path}'"
            )

        if value is not None:
            self._set_nested_value(context_vars, target_name, value)

    context_vars["__service_account__"] = self.name
    return context_vars
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"external_state"} type={"dict[str, Any]"} value={null} />

</div>

<PyFunctionReturn type={"dict[str, Any]"} />

</PyFunction>

<PyFunction name={"_get_nested_value"} type={"_get_nested_value(self, /, data, path) -> Any"}>

<PySourceCode >

```python
def _get_nested_value(self, data: dict[str, Any], path: str) -> Any:
    keys = path.split(".")
    current = data

    for key in keys:
        if isinstance(current, dict) and key in current:
            current = current[key]
        else:
            return None

    return current
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"data"} type={"dict[str, Any]"} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />

</div>

<PyFunctionReturn type={"Any"} />

</PyFunction>

<PyFunction name={"_set_nested_value"} type={"_set_nested_value(self, /, data, path, value) -> None"}>

<PySourceCode >

```python
def _set_nested_value(self, data: dict[str, Any], path: str, value: Any) -> None:
    keys = path.split(".")
    current = data

    for key in keys[:-1]:
        if key not in current:
            current[key] = {}
        current = current[key]

    current[keys[-1]] = value
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"data"} type={"dict[str, Any]"} value={null} />
<PyParameter name={"path"} type={"str"} value={null} />
<PyParameter name={"value"} type={"Any"} value={null} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
