---
title: Component
---

## Attributes

<PyAttribute
  name={"__slots__"}
  type={null}
  value={
    "('id', 'name', 'strict', 'spec', 'yaml_path', 'registry', '_initial_data')"
  }
/>

<PyAttribute name={"spec"} type={"S"} value={"spec"} />

<PyAttribute name={"spec_type"} type={"type[S]"} value={null} />

<PyAttribute name={"yaml_path"} type={null} value={"yaml_path"} />

<PyAttribute name={"strict"} type={null} value={"strict"} />

<PyAttribute name={"registry"} type={null} value={"registry"} />

<PyAttribute name={"id"} type={null} value={"self.generate_id()"} />

<PyAttribute name={"name"} type={null} value={"self.spec.name"} />

<PyAttribute name={"full_name"} type={"str"} value={null} />

## Functions

<PyFunction name={"__init__"} type={"__init__(self, /, spec, registry, *, initial_data=None, yaml_path=None, strict=False) -> None"}>

<PySourceCode >

```python
def __init__(
    self,
    spec: S,
    registry: Registry,
    *,
    initial_data: dict[str, Any] | None = None,
    yaml_path: str | None = None,
    strict: bool = False,
) -> None:
    self._initial_data = initial_data
    self.spec = spec
    self.yaml_path = yaml_path
    self.strict = strict
    self.registry = registry

    self.id = self.generate_id()
    self.name = self.spec.name
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"spec"} type={"S"} value={null} />
<PyParameter name={"registry"} type={"Registry"} value={null} />
<PyParameter
  name={"initial_data"}
  type={"dict[str, Any] | None"}
  value={"None"}
/>
<PyParameter name={"yaml_path"} type={"str | None"} value={"None"} />
<PyParameter name={"strict"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>

<PyFunction name={"__repr__"} type={"__repr__(self) -> str"}>

<PySourceCode >

```python
def __repr__(self) -> str:
    return f"{self.spec.kind}:{self.name}"
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"str"} />

</PyFunction>

<PyFunction name={"from_dict"} type={"from_dict(cls, /, data, registry, *, yaml_path=None, strict=False, **kwargs) -> Self"}>

Create a Component from a dict spec

Args:
data (dict[str, Any]): Dictionary containing the BaseNode spec.
yaml_path (str | None): Path to the YAML file if the data is loaded from a YAML file.
strict (bool): Whether to enforce strict validation of the spec and other internal checks.
\*\*kwargs: Additional keyword arguments specific to the subclass.

Returns:
Component: An instance of initialized Component

<PySourceCode >

```python
@classmethod
def from_dict(
    cls,
    data: dict[str, Any],
    registry: Registry,
    *,
    yaml_path: str | None = None,
    strict: bool = False,
    **kwargs: Any,
) -> Self:
    """
    Create a Component from a dict spec

    Args:
        data (dict[str, Any]): Dictionary containing the BaseNode spec.
        yaml_path (str | None): Path to the YAML file if the data is loaded from a YAML file.
        strict (bool): Whether to enforce strict validation of the spec and other internal checks.
        **kwargs: Additional keyword arguments specific to the subclass.

    Returns:
        Component: An instance of initialized Component
    """
    # Create extended spec with plugin fields
    plugins = registry.get_plugins(cls.__name__)
    ExtendedSpecClass = cls.create_extended_spec(cls.spec_type, plugins, data)

    spec = ExtendedSpecClass.model_validate(data, strict=strict)

    return cls(
        spec=spec,
        registry=registry,
        initial_data=data,
        yaml_path=yaml_path,
        strict=strict,
        **kwargs,
    )
```

</PySourceCode>

<div >

<PyParameter name={"cls"} type={null} value={null} />
<PyParameter name={"data"} type={"dict[str, Any]"} value={null} />
<PyParameter name={"registry"} type={"Registry"} value={null} />
<PyParameter name={"yaml_path"} type={"str | None"} value={"None"} />
<PyParameter name={"strict"} type={"bool"} value={"False"} />
<PyParameter name={"kwargs"} type={"Any"} value={"{}"} />

</div>

<PyFunctionReturn type={"Self"} />

</PyFunction>

<PyFunction name={"from_yaml_path"} type={"from_yaml_path(cls, /, yaml_path, registry, *, strict=True, **kwargs) -> ComponentT"}>

Create a Component from a YAML file.

Args:
yaml_path (str | Path): Path to the YAML file.
registry (Registry): Registry instance for plugins.

Returns:
Component: An instance of Component initialized with the YAML data.

<PySourceCode >

```python
@classmethod
def from_yaml_path(
    cls: type[ComponentT],
    yaml_path: str | Path,
    registry: Registry,
    *,
    strict: bool = True,
    **kwargs: Any,
) -> ComponentT:
    """
    Create a Component from a YAML file.

    Args:
        yaml_path (str | Path): Path to the YAML file.
        registry (Registry): Registry instance for plugins.

    Returns:
        Component: An instance of Component initialized with the YAML data.
    """
    yaml_path_str = str(yaml_path)
    yaml = YAML()
    with open(yaml_path_str, encoding="utf-8") as fd:
        yaml_data = yaml.load(fd)

    if not isinstance(yaml_data, dict):
        raise InvalidSpecError(
            "YAML content must be a dictionary at the top level."
        )

    return cls.from_dict(
        yaml_data,
        registry,
        yaml_path=yaml_path_str,
        strict=strict,
        **kwargs,
    )
```

</PySourceCode>

<div >

<PyParameter name={"cls"} type={"type[ComponentT]"} value={null} />
<PyParameter name={"yaml_path"} type={"str | Path"} value={null} />
<PyParameter name={"registry"} type={"Registry"} value={null} />
<PyParameter name={"strict"} type={"bool"} value={"True"} />
<PyParameter name={"kwargs"} type={"Any"} value={"{}"} />

</div>

<PyFunctionReturn type={"ComponentT"} />

</PyFunction>

<PyFunction name={"generate_id"} type={"generate_id(self) -> UUID"}>

<PySourceCode >

```python
def generate_id(self) -> UUID:
    return uuid4()
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />

</div>

<PyFunctionReturn type={"UUID"} />

</PyFunction>

<PyFunction name={"create_extended_spec"} type={"create_extended_spec(cls, /, base_spec_class, plugins, data) -> type[S]"}>

Create extended spec class with plugin fields and validate data.

Returns:
Tuple of (ExtendedSpecClass, validated_data)

<PySourceCode >

```python
@classmethod
def create_extended_spec(
    cls, base_spec_class: type[S], plugins: Sequence[Plugin], data: dict[str, Any]
) -> type[S]:
    """
    Create extended spec class with plugin fields and validate data.

    Returns:
        Tuple of (ExtendedSpecClass, validated_data)
    """
    if not plugins:
        return base_spec_class

    kind = data.get("kind")
    if not kind:
        raise InvalidSpecError("Spec data must contain 'kind' field")

    plugin_fields: dict[str, Any] = {}
    for plugin in plugins:
        if kind not in plugin.applies_to:
            continue

        if hasattr(base_spec_class, plugin.field_name):
            raise PluginFieldConflictError(
                f"Field '{plugin.field_name}' already exists in {kind} spec"
            )

        plugin_fields[plugin.field_name] = (plugin.field_type, Field(default=None))

    if plugin_fields:
        ExtendedSpecClass = create_model(
            f"{base_spec_class.__name__}WithPlugins",
            __base__=base_spec_class,
            **plugin_fields,
        )
        return ExtendedSpecClass

    return base_spec_class
```

</PySourceCode>

<div >

<PyParameter name={"cls"} type={null} value={null} />
<PyParameter name={"base_spec_class"} type={"type[S]"} value={null} />
<PyParameter name={"plugins"} type={"Sequence[Plugin]"} value={null} />
<PyParameter name={"data"} type={"dict[str, Any]"} value={null} />

</div>

<PyFunctionReturn type={"type[S]"} />

</PyFunction>

<PyFunction name={"print_spec"} type={"print_spec(self, /, initial=False) -> None"}>

Print the tool node specification in YAML format.
Args:
raw (bool): If True, print the raw declaration; otherwise, print the validated spec.

<PySourceCode >

```python
def print_spec(self, initial: bool = False) -> None:
    """
    Print the tool node specification in YAML format.
    Args:
        raw (bool): If True, print the raw declaration; otherwise, print the validated spec.
    """
    yaml = YAML()
    yaml.indent(mapping=2, sequence=4, offset=2)
    yaml.preserve_quotes = True

    yaml_spec = StringIO()

    if initial:
        to_dump = _preserve_multiline_strings(self._initial_data)
    else:
        to_dump = _preserve_multiline_strings(
            self.spec.model_dump(exclude_none=True)
        )

    yaml.dump(to_dump, yaml_spec)
    syntax = Syntax(
        yaml_spec.getvalue(),
        "yaml",
        theme="monokai",
        background_color="default",
        word_wrap=True,
    )
    rich_print(syntax)
```

</PySourceCode>

<div >

<PyParameter name={"self"} type={null} value={null} />
<PyParameter name={"initial"} type={"bool"} value={"False"} />

</div>

<PyFunctionReturn type={"None"} />

</PyFunction>
